//首先说明：Rust是强类型语言，但具有自动判断变量类型的能力。如果需要声明变量，需要使用let关键字。

fn main() {
    let a = 123;

    a = "abc";
    a = 4.56;
    a= 456; 

    /**
     * 上面三行代码都是被禁止的
     * 第一行的错误在于当声明a是124之后，a就被确定为整型数字，不能把字符串类型的值赋给它
     * 第二行的错误在于自动转换数字精度有损失，Rust语言不允许精度有损失的自动数据类型转换。
     * 第三行的错误在于a不是个可变变量
     * 
     * Rust语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变，所以a的值不可变，但这不意味着a不是“变量”，官方文档称这种变量为“不可变变量”
     * 如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转，由于这种原因造成的错误很难在事后找到。这是Rust语言设计这种机制的原因
     * 
     */

    let mut a = 123; //使得变量可变，只需要加一个mut关键字e即可
    a = 456;

    /**
     * 常量和不可变变量之间的区别
     */

    let a = 123; //可以编译，但可能有警告，因为该变量没有被使用
    let a = 456;

    const a: i32 = 123; //不合法，因为a是常量
    let a = 456;

    /**
     * 变量的值可以“重新绑定”，但在“重新绑定”以前不能i四组被改变，这样可以确保在每一次“绑定”之后的区域里编译器可以充分推理程序逻辑。
     * 
     * 虽然Rust有自动判断类型的功能，但是有些情况下声明类型更加方便：
     */
    let a: u64 = 123; //这里声明了a为无符号的整型变量，如果没有声明类型，a将自动被判断为有符号的32位n整型变量，这对于a的取值范围有很大的影响。

    
    
}